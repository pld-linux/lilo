diff -Naur lilo-22.2/Makefile lilo-22.2-evms/Makefile
--- lilo-22.2/Makefile	Wed Feb  6 00:27:27 2002
+++ lilo-22.2-evms/Makefile	Mon Feb 18 10:32:19 2002
@@ -24,6 +24,8 @@
 # * LVM		  Enables support for booting from LVM partitions.  This will
 #		  OOPS if you try to use this and are using a kernel < 2.4.7
 #		  that has not been patched to at least LVM 0.9.1beta6 (new)
+# * EVMS	  Enables support for booting from EVMS volumes. Requires a
+#		  2.4 or 2.5 kernel patched to EVMS version 0.9.2 or later.
 # * M386	  Use 386 instructions in assembly code to reduce size of
 #		  second-stage loader (recommended)
 #   NO1STDIAG	  Don't show diagnostic on read errors in the first stage
@@ -48,8 +50,8 @@
 # * VERSION	  Prints version string at LILO boot prompt.
 #   XL_SECS=n	  Support for extra large (non-standard) floppies.
 
-CONFIG=-DBDATA -DDSECS=3 -DIGNORECASE -DLBA32 -DLVM -DM386 -DONE_SHOT -DPASS160\
-   -DREISERFS -DREWRITE_TABLE -DSOLO_CHAIN -DVARSETUP -DVERSION
+CONFIG=-DBDATA -DDSECS=3 -DIGNORECASE -DLBA32 -DLVM -DEVMS -DM386 -DONE_SHOT \
+   -DPASS160 -DREISERFS -DREWRITE_TABLE -DSOLO_CHAIN -DVARSETUP -DVERSION
 
 LILOX=-DCODE_START_1=136 -DCODE_START_2=14
 
diff -Naur lilo-22.2/geometry.c lilo-22.2-evms/geometry.c
--- lilo-22.2/geometry.c	Wed Nov 28 21:03:57 2001
+++ lilo-22.2-evms/geometry.c	Tue Feb 19 15:53:06 2002
@@ -63,6 +63,27 @@
 #endif
 #endif
 
+#ifdef LCF_EVMS
+struct evms_get_bmap_t {
+    __u64 rsector;
+    __u32 dev;
+    int status;
+};
+
+struct evms_version_t {
+    __u32 major;
+    __u32 minor;
+    __u32 patch;
+};
+
+#ifndef EVMS_GET_BMAP
+#define EVMS_GET_BMAP		_IOWR(MAJOR_EVMS, 0xC7, struct evms_get_bmap_t)
+#endif
+#ifndef EVMS_GET_IOCTL_VERSION
+#define EVMS_GET_IOCTL_VERSION	_IOR(MAJOR_EVMS, 0x0, struct evms_version_t)
+#endif
+#endif
+
 #ifndef HDIO_GETGEO
 #define HDIO_GETGEO HDIO_REQ
 #endif
@@ -345,6 +366,50 @@
 #endif
 
 
+#ifdef LCF_EVMS
+void evms_bmap(struct evms_get_bmap_t *ebm)
+{                                  
+    DEVICE dev;
+    static int evms_fd = -1;
+    static dev_t evms_last_dev = 0;
+
+    if (ebm->dev != evms_last_dev) {
+        char evms_blk[] = "/dev/evms/block_device";
+        struct evms_version_t evms_ver;
+
+        // Open the EVMS device
+        if (evms_fd != -1)
+            close(evms_fd);
+
+        evms_fd = open(evms_blk, O_RDONLY);
+        if (evms_fd < 0)
+            die("Can't open EVMS block device %s.\n", evms_blk);
+
+        // Get EVMS ioctl version number.
+        if (ioctl(evms_fd, EVMS_GET_IOCTL_VERSION, &evms_ver) < 0)
+            die("EVMS_GET_IOCTL_VERSION failed on %s.\n", evms_blk);
+
+        // Check that the ioctl version is >= 7.1.0
+        if (evms_ver.major < 7 ||
+            (evms_ver.major == 7 && evms_ver.minor < 1))
+            die("EVMS ioctl version %d.%d.%d does not support booting.\n",
+                evms_ver.major, evms_ver.minor, evms_ver.patch);
+        close(evms_fd);
+
+        evms_fd = dev_open(&dev, ebm->dev, O_RDONLY);
+        if (evms_fd < 0)
+            die("Can't open EVMS block device %#x\n", ebm->dev);
+        evms_last_dev = ebm->dev;
+    }
+
+    if (ioctl(evms_fd, EVMS_GET_BMAP, ebm) < 0) {
+        perror(__FUNCTION__);
+        pdie("EVMS_GET_BMAP error or ioctl unsupported. Can't have image on EVMS volume.\n");
+    }
+}
+#endif
+
+
 static void geo_query_dev(GEOMETRY *geo,int device,int all)
 {
     DEVICE dev;
@@ -622,6 +687,21 @@
 	device = geo->base_dev = lbmA.lv_dev;
     }
 #endif
+
+#ifdef LCF_EVMS
+    if (MAJOR(device) == MAJOR_EVMS) {
+        struct evms_get_bmap_t ebm;
+        
+        ebm.rsector = 0;
+        ebm.dev = device;
+        ebm.status = 0;
+        
+        evms_bmap(&ebm);
+        
+        device = geo->base_dev = ebm.dev;
+    }
+#endif
+
     /* Find underlying device for MD RAID */
     if (MAJOR(device) == MD_MAJOR) {
         char mdxxx[16];
@@ -824,8 +904,28 @@
 	block = lbm.lv_block;
     }
 #endif
+
+#ifdef LCF_EVMS
+    if (MAJOR(geo->dev) == MAJOR_EVMS) {
+        struct evms_get_bmap_t ebm;
+                          
+        ebm.rsector = block * geo->spb;
+        ebm.dev = geo->dev;
+        ebm.status = 0;
+                            
+        evms_bmap(&ebm);
+        if (ebm.dev != geo->base_dev)
+            die("EVMS boot volume cannot be on multiple disks.\n");
+        sector = ebm.rsector + ((offset/SECTOR_SIZE) % geo->spb) + geo->start;
+    }
+    else {
+        sector = block*geo->spb+((offset/SECTOR_SIZE) % geo->spb);
+        sector += geo->start;
+    }
+#else
     sector = block*geo->spb+((offset/SECTOR_SIZE) % geo->spb);
     sector += geo->start;
+#endif
  /*   Always use CHS addressing on floppies:     JRC   */
     if ((geo->device & 0x80) && (linear || lba32)) {
         addr->device = geo->device | (linear ? LINEAR_FLAG : (LBA32_FLAG|LBA32_NOCOUNT))
diff -Naur lilo-22.2/lilo.h lilo-22.2-evms/lilo.h
--- lilo-22.2/lilo.h	Wed Nov 28 21:03:57 2001
+++ lilo-22.2-evms/lilo.h	Mon Feb 18 10:27:34 2002
@@ -56,6 +56,7 @@
 #define MAJOR_IDE6	57 /* IDE on sixth interface */
 #define MAJOR_LVM	58 /* Logical Volume Manager block device */
 #define MAJOR_FL	62 /* M-Systems Disk-On-Chip 2000 ***experimental*** */
+#define MAJOR_EVMS	63 /* Enterprise Volume Management System */
 #define MAJOR_SD2	65 /* SCSI disks 16-31 */
 #define MAJOR_SD3	66 /* SCSI disks 32-47 */
 #define MAJOR_SD4	67 /* SCSI disks 48-63 */
